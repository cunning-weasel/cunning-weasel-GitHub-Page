## Low level gang, dangling pointers and how I love to punish myself

There's always been something that tickled my fancy about low-level programming. Some call it systems programming, others low-level, and the last group would refer to it all as embedded (although that, again, can mean a stricter set of hardware - and an entirely different architectural paradim, but I digress).

Like many programmers before me, I fell in love with tech because of games. And games, to me, outside of a few cases like real-time, high-frequency trading platforms, real-time physics and computations a-la computer vision in self-driving cars, and a few cases of crypto mining here and there as well as high traffic distributed systems - there really isn't a better test and showcase of the hardware and software leaps we've made within the last 3 or so decades.

It often fascinated me how games would require the end-user to tune the settings - here being graphics fedelity, physics, number of objects on-screen and more - to get the exact match that run best on their desired hardware.

And often, the telltale of optimized, well performant software in these cases, is how well you can match the software to run on your specific hardware. 

It's a far cry from the web-dec world where I dwell. I often think we've gotten too framework and library-dependant. Many programmers I know will often reach for a library or extension to achieve the same things they could if they sat down and focused on writing code for an afternoon. 